{"ast":null,"code":"/**\n * Create a new prediction\n *\n * @param {object} options\n * @param {string} options.version - Required. The model version\n * @param {object} options.input - Required. An object with the model inputs\n * @param {boolean|object} [options.wait] - Whether to wait for the prediction to finish. Defaults to false\n * @param {number} [options.wait.interval] - Polling interval in milliseconds. Defaults to 250\n * @param {number} [options.wait.maxAttempts] - Maximum number of polling attempts. Defaults to no limit\n * @param {string} [options.webhook] - An HTTPS URL for receiving a webhook when the prediction has new output\n * @param {string[]} [options.webhook_events_filter] - You can change which events trigger webhook requests by specifying webhook events (`start`|`output`|`logs`|`completed`)\n * @returns {Promise<object>} Resolves with the created prediction data\n */\nasync function createPrediction(options) {\n  const {\n    wait,\n    ...data\n  } = options;\n  if (data.webhook) {\n    try {\n      // eslint-disable-next-line no-new\n      new URL(data.webhook);\n    } catch (err) {\n      throw new Error('Invalid webhook URL');\n    }\n  }\n  const prediction = this.request('/predictions', {\n    method: 'POST',\n    data\n  });\n  if (wait) {\n    const {\n      maxAttempts,\n      interval\n    } = wait;\n\n    // eslint-disable-next-line no-promise-executor-return\n    const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\n    await sleep(interval || 250);\n    return this.wait(await prediction, {\n      maxAttempts,\n      interval\n    });\n  }\n  return prediction;\n}\n\n/**\n * Fetch a prediction by ID\n *\n * @param {number} prediction_id - Required. The prediction ID\n * @returns {Promise<object>} Resolves with the prediction data\n */\nasync function getPrediction(prediction_id) {\n  return this.request(`/predictions/${prediction_id}`, {\n    method: 'GET'\n  });\n}\n\n/**\n * Cancel a prediction by ID\n *\n * @param {string} prediction_id - Required. The training ID\n * @returns {Promise<object>} Resolves with the data for the training\n */\nasync function cancelPrediction(prediction_id) {\n  return this.request(`/predictions/${prediction_id}/cancel`, {\n    method: 'POST'\n  });\n}\n\n/**\n * List all predictions\n *\n * @returns {Promise<object>} - Resolves with a page of predictions\n */\nasync function listPredictions() {\n  return this.request('/predictions', {\n    method: 'GET'\n  });\n}\nmodule.exports = {\n  create: createPrediction,\n  get: getPrediction,\n  cancel: cancelPrediction,\n  list: listPredictions\n};","map":{"version":3,"names":["createPrediction","options","wait","data","webhook","URL","err","Error","prediction","request","method","maxAttempts","interval","sleep","ms","Promise","resolve","setTimeout","getPrediction","prediction_id","cancelPrediction","listPredictions","module","exports","create","get","cancel","list"],"sources":["C:/Users/priya/Desktop/try/chatvision-web/node_modules/replicate/lib/predictions.js"],"sourcesContent":["/**\n * Create a new prediction\n *\n * @param {object} options\n * @param {string} options.version - Required. The model version\n * @param {object} options.input - Required. An object with the model inputs\n * @param {boolean|object} [options.wait] - Whether to wait for the prediction to finish. Defaults to false\n * @param {number} [options.wait.interval] - Polling interval in milliseconds. Defaults to 250\n * @param {number} [options.wait.maxAttempts] - Maximum number of polling attempts. Defaults to no limit\n * @param {string} [options.webhook] - An HTTPS URL for receiving a webhook when the prediction has new output\n * @param {string[]} [options.webhook_events_filter] - You can change which events trigger webhook requests by specifying webhook events (`start`|`output`|`logs`|`completed`)\n * @returns {Promise<object>} Resolves with the created prediction data\n */\nasync function createPrediction(options) {\n  const { wait, ...data } = options;\n\n  if (data.webhook) {\n    try {\n      // eslint-disable-next-line no-new\n      new URL(data.webhook);\n    } catch (err) {\n      throw new Error('Invalid webhook URL');\n    }\n  }\n\n  const prediction = this.request('/predictions', {\n    method: 'POST',\n    data,\n  });\n\n  if (wait) {\n    const { maxAttempts, interval } = wait;\n\n    // eslint-disable-next-line no-promise-executor-return\n    const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n    await sleep(interval || 250);\n\n    return this.wait(await prediction, { maxAttempts, interval });\n  }\n\n  return prediction;\n}\n\n/**\n * Fetch a prediction by ID\n *\n * @param {number} prediction_id - Required. The prediction ID\n * @returns {Promise<object>} Resolves with the prediction data\n */\nasync function getPrediction(prediction_id) {\n  return this.request(`/predictions/${prediction_id}`, {\n    method: 'GET',\n  });\n}\n\n/**\n * Cancel a prediction by ID\n *\n * @param {string} prediction_id - Required. The training ID\n * @returns {Promise<object>} Resolves with the data for the training\n */\nasync function cancelPrediction(prediction_id) {\n  return this.request(`/predictions/${prediction_id}/cancel`, {\n    method: 'POST',\n  });\n}\n\n/**\n * List all predictions\n *\n * @returns {Promise<object>} - Resolves with a page of predictions\n */\nasync function listPredictions() {\n  return this.request('/predictions', {\n    method: 'GET',\n  });\n}\n\nmodule.exports = {\n  create: createPrediction,\n  get: getPrediction,\n  cancel: cancelPrediction,\n  list: listPredictions,\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeA,gBAAgBA,CAACC,OAAO,EAAE;EACvC,MAAM;IAAEC,IAAI;IAAE,GAAGC;EAAK,CAAC,GAAGF,OAAO;EAEjC,IAAIE,IAAI,CAACC,OAAO,EAAE;IAChB,IAAI;MACF;MACA,IAAIC,GAAG,CAACF,IAAI,CAACC,OAAO,CAAC;IACvB,CAAC,CAAC,OAAOE,GAAG,EAAE;MACZ,MAAM,IAAIC,KAAK,CAAC,qBAAqB,CAAC;IACxC;EACF;EAEA,MAAMC,UAAU,GAAG,IAAI,CAACC,OAAO,CAAC,cAAc,EAAE;IAC9CC,MAAM,EAAE,MAAM;IACdP;EACF,CAAC,CAAC;EAEF,IAAID,IAAI,EAAE;IACR,MAAM;MAAES,WAAW;MAAEC;IAAS,CAAC,GAAGV,IAAI;;IAEtC;IACA,MAAMW,KAAK,GAAIC,EAAE,IAAK,IAAIC,OAAO,CAAEC,OAAO,IAAKC,UAAU,CAACD,OAAO,EAAEF,EAAE,CAAC,CAAC;IACvE,MAAMD,KAAK,CAACD,QAAQ,IAAI,GAAG,CAAC;IAE5B,OAAO,IAAI,CAACV,IAAI,CAAC,MAAMM,UAAU,EAAE;MAAEG,WAAW;MAAEC;IAAS,CAAC,CAAC;EAC/D;EAEA,OAAOJ,UAAU;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeU,aAAaA,CAACC,aAAa,EAAE;EAC1C,OAAO,IAAI,CAACV,OAAO,CAAE,gBAAeU,aAAc,EAAC,EAAE;IACnDT,MAAM,EAAE;EACV,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeU,gBAAgBA,CAACD,aAAa,EAAE;EAC7C,OAAO,IAAI,CAACV,OAAO,CAAE,gBAAeU,aAAc,SAAQ,EAAE;IAC1DT,MAAM,EAAE;EACV,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAeW,eAAeA,CAAA,EAAG;EAC/B,OAAO,IAAI,CAACZ,OAAO,CAAC,cAAc,EAAE;IAClCC,MAAM,EAAE;EACV,CAAC,CAAC;AACJ;AAEAY,MAAM,CAACC,OAAO,GAAG;EACfC,MAAM,EAAExB,gBAAgB;EACxByB,GAAG,EAAEP,aAAa;EAClBQ,MAAM,EAAEN,gBAAgB;EACxBO,IAAI,EAAEN;AACR,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}